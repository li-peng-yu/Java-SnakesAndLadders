import java.util.ArrayList;
import java.util.List;
import java.util.Random;
/**
 * 游戏引擎核心类，整合玩家管理、骰子、游戏逻辑
 */
public class Gameengine {
    // 玩家列表
    private List<Player> players = new ArrayList<>();
    // 当前玩家索引
    private int currentPlayerIndex;
    // 游戏是否结束标志
    private boolean gameOver;
    // 胜利者
    private Player winner;
    // 随机数生成器（用于骰子）
    private Random random = new Random();
    // 游戏模式标志 (true为单人模式，false为双人模式)
    private boolean singlePlayerMode;
    /**特殊格子定义 [位置, 目标位置]，私有静态不可变二维数组常量
     * 使用SPECIAL-CELLS可以访问数组中的元素*/

    
    //玩家内部类
    class Player {
        String name;    // 玩家名称
        int position;   // 当前位置
        boolean isGuest;// 是否为游客

        Player(String name, boolean isGuest) {
            this.name = name;
            this.position = 0;  // 初始位置0表示未开始
            this.isGuest = isGuest;
        }
    }

    /**
     * 构造函数初始化游戏
     * @param playerNames 玩家名称列表
     */
    public Gameengine(List<String> playerNames) {
        // 根据名称创建玩家对象
        for (String name : playerNames) {
            players.add(new Player(name, name.equals("Guest")));
        }
        currentPlayerIndex = 0;  // 从第一个玩家开始
        singlePlayerMode = (playerNames.size() == 1); // 单人模式判断
    }

    /**
     * 判断是否为单人模式
     * @return true如果是单人模式，false如果是双人模式
     */
    public boolean isSinglePlayerMode() {
        return singlePlayerMode;
    }

    /**
     * 获取当前游戏玩家数量
     * @return 玩家数量
     */
    public int getPlayerCount() {
        return players.size();
    }

    /**
     * 单人模式下AI自动掷骰子
     * @return 骰子点数（1-6），-1表示游戏已结束
     */
    public int aiRollDice() {
        if (!singlePlayerMode || gameOver) return -1;
        
        // AI简单逻辑：随机掷骰子
        int steps = random.nextInt(6) + 1;
        movePlayer(steps);
        
        // 检查游戏是否因AI移动而结束
        if (!gameOver) {
            currentPlayerIndex = 0; // 切换回人类玩家
        }
        return steps;
    }

    /**
     * 掷骰子并移动当前玩家
     * @return 骰子点数（1-6），-1表示游戏已结束
     */
    public int rollDice() {
        if (gameOver) return -1;

        // 生成1-6随机数
        int steps = random.nextInt(6) + 1;
        // 移动当前玩家
        movePlayer(steps);

        // 如果游戏未结束，切换到下一个玩家
        if (!gameOver) {
            // 单人模式下只在人类和AI之间切换
            currentPlayerIndex = singlePlayerMode ? 0 : (currentPlayerIndex + 1) % players.size();
        }
        return steps;
    }

    /**
     * 移动玩家逻辑
     * @param steps 移动步数
     */
    private static final int[][] SPECIAL_CELLS = {
            {4,14}, {9,31}, {17,7}, {21,42}, {28,84},
            {51,67}, {54,34}, {62,19}, {64,60}, {71,91},
            {80,100}, {87,24}, {93,73}, {95,75}, {98,79}
    };//
    private void movePlayer(int steps) {
        Player p = players.get(currentPlayerIndex);
        // 计算新位置
        int newPos = p.position + steps;

        // 弹回逻辑：超过100时反弹
        if (newPos > 100) {
            newPos = 100 - (newPos - 100);
        }

        // 检查特殊格子
        for (int[] cell : SPECIAL_CELLS) {//在数组special cells中遍历一维数组cell
            if (cell[0] == newPos) {//如果第一个元素一样那么就给第二个索引为1的元素赋值给newposition
                newPos = cell[1];  // 应用特殊格子效果
                break;
            }
        }

        // 更新玩家位置
        p.position = newPos;

        // 检查是否获胜
        if (newPos == 100) {
            gameOver = true;
            winner = p;
        }
    }

    //  获取游戏状态的方法 get方法

    /** 获取当前玩家 */
    public Player getCurrentPlayer() {
        return players.get(currentPlayerIndex);
    }

    /** 检查游戏是否结束 */
    public boolean isGameOver() {
        return gameOver;
    }

    /** 获取胜利者 */
    public Player getWinner() {
        return winner;
    }

    /** 重新开始游戏 */
    public void restart() {
        // 重置所有玩家位置
        players.forEach(p -> p.position = 0);
        currentPlayerIndex = 0;  // 重置到第一个玩家
        gameOver = false;       // 重置游戏状态
        winner = null;          // 清除胜利者
    }
}
